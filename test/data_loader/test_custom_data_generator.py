#!/usr/bin/env python3
"""
Test script for custom data generator functionality in the generic data generation framework.

This test verifies that users can implement custom data generators and integrate them 
with the generic data generation pipeline.
"""

import sys
import os
import numpy as np
import tempfile
import shutil
from pathlib import Path

# Add paths for local modules
sys.path.append(os.path.join(os.path.dirname(__file__), "..", "..", "data_loader", "src"))
sys.path.append(os.path.join(os.path.dirname(__file__), "..", "..", "data_loader", "moose"))

from generic_data_generator import SimulationRunner, DataExtractor, GenericDataGenerationPipeline


class CustomSimulationRunner(SimulationRunner):
    """
    Custom simulation runner for testing purposes.
    
    This class simulates running a computational simulation by generating synthetic data
    based on input parameters.
    """
    
    def run_simulation(self, input_file: str, output_dir: str, parameters: dict) -> dict:
        """
        Run a custom simulation that generates synthetic data based on parameters.
        
        Args:
            input_file: Path to input template file
            output_dir: Directory to store simulation outputs
            parameters: Dictionary of simulation parameters
            
        Returns:
            Dictionary containing simulation results
        """
        # Create output directory if it doesn't exist
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        
        # Generate synthetic simulation output based on parameters
        # In a real implementation, this would run an actual simulation
        result_data = self._generate_synthetic_data(parameters)
        
        # Save the synthetic data to a file
        output_file = os.path.join(output_dir, "simulation_output.npy")
        np.save(output_file, result_data)
        
        return {
            "status": "success",
            "parameters": parameters,
            "output_file": output_file,
            "sim_dir": output_dir
        }
    
    def _generate_synthetic_data(self, parameters: dict) -> np.ndarray:
        """
        Generate synthetic data based on input parameters.
        
        Args:
            parameters: Dictionary of simulation parameters
            
        Returns:
            NumPy array containing synthetic simulation data
        """
        # Extract parameters with defaults
        amplitude = parameters.get("amplitude", 1.0)
        frequency = parameters.get("frequency", 1.0)
        phase = parameters.get("phase", 0.0)
        noise_level = parameters.get("noise_level", 0.1)
        data_size = parameters.get("data_size", 100)
        
        # Generate synthetic data: sine wave with noise
        x = np.linspace(0, 2 * np.pi, data_size)
        y = amplitude * np.sin(frequency * x + phase)
        
        # Add noise
        noise = np.random.normal(0, noise_level, data_size)
        y_noisy = y + noise
        
        # Return data as a 2D array (features, targets)
        return np.column_stack([x, y_noisy])


class CustomDataExtractor(DataExtractor):
    """
    Custom data extractor for testing purposes.
    
    This class extracts data from simulation output files generated by the custom simulation runner.
    """
    
    def extract_data(self, file_path: str, parameters: dict = None) -> dict:
        """
        Extract data from simulation output file.
        
        Args:
            file_path: Path to simulation output file
            parameters: Optional parameters used in simulation
            
        Returns:
            Dictionary containing extracted data
        """
        # Load the synthetic data
        data = np.load(file_path)
        
        # Extract features and targets
        features = data[:, 0]  # x values
        targets = data[:, 1]   # y values (noisy sine wave)
        
        return {
            "features": features,
            "targets": targets
        }


def test_custom_data_generator():
    """
    Test the custom data generator implementation.
    
    This test verifies that:
    1. Custom simulation runner can generate data
    2. Custom data extractor can extract data
    3. Generic pipeline can work with custom components
    """
    print("Testing custom data generator...")
    
    # Create temporary directories for test
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)
        simulation_output_dir = temp_path / "simulations"
        dataset_dir = temp_path / "dataset"
        
        # Create a simple input template (not actually used in this test)
        input_template = temp_path / "input_template.txt"
        input_template.write_text("This is a template file for custom simulations.")
        
        # Configuration for the custom data generator
        config = {
            "solver": "custom",
            "solver_config": {
                "custom_solver_class": "__main__.CustomSimulationRunner",
                "working_dir": str(temp_path),
                "timeout": 30
            },
            "extractor": "custom",
            "extractor_config": {
                "custom_extractor_class": "__main__.CustomDataExtractor"
            },
            "base_input_file": str(input_template),
            "simulation_output_dir": str(simulation_output_dir),
            "dataset_dir": str(dataset_dir),
            "parameters": {
                "amplitude": {
                    "type": "uniform",
                    "min": 0.5,
                    "max": 2.0
                },
                "frequency": {
                    "type": "uniform",
                    "min": 0.5,
                    "max": 3.0
                },
                "phase": {
                    "type": "uniform",
                    "min": 0.0,
                    "max": 2 * np.pi
                },
                "noise_level": {
                    "type": "fixed",
                    "value": 0.1
                },
                "data_size": {
                    "type": "fixed",
                    "value": 100
                }
            },
            "num_samples": 5,
            "normalize": True,
            "model_name": "mlp",
            "epochs": 10,
            "batch_size": 4,
            "learning_rate": 0.001,
            "use_gpu": False
        }
        
        try:
            # Create and run the pipeline
            pipeline = GenericDataGenerationPipeline(config)
            results = pipeline.run_pipeline()
            
            # Verify results
            assert results is not None, "Pipeline should return results"
            assert "simulation_results" in results, "Results should contain simulation results"
            assert "dataset" in results, "Results should contain dataset"
            
            sim_results = results["simulation_results"]
            dataset = results["dataset"]
            
            # Check simulation results
            assert sim_results["total_count"] == 5, f"Expected 5 simulations, got {sim_results['total_count']}"
            assert sim_results["successful_count"] >= 0, "Should have non-negative successful count"
            assert os.path.exists(sim_results["output_dir"]), "Simulation output directory should exist"
            
            # Check dataset
            assert dataset is not None, "Dataset should not be None"
            assert "parameters" in dataset, "Dataset should contain parameters"
            assert "output_data" in dataset, "Dataset should contain output data"
            assert "metadata" in dataset, "Dataset should contain metadata"
            
            parameters = dataset["parameters"]
            output_data = dataset["output_data"]
            
            # Check data shapes
            assert parameters.shape[0] == sim_results["successful_count"], \
                "Parameters count should match successful simulations"
            assert output_data.shape[0] == sim_results["successful_count"], \
                "Output data count should match successful simulations"
            
            # Check that files were created in the correct locations
            assert os.path.exists(dataset_dir), "Dataset directory should exist"
            assert os.path.exists(dataset_dir / "parameters.npy"), "Parameters file should exist"
            assert os.path.exists(dataset_dir / "output_data.npy"), "Output data file should exist"
            assert os.path.exists(dataset_dir / "metadata.json"), "Metadata file should exist"
            # The simulation_results.json file is created in the simulation output directory, not dataset directory
            assert os.path.exists(simulation_output_dir / "simulation_results.json"), "Simulation results file should exist"
            
            print("✓ Custom data generator test passed")
            return True
            
        except Exception as e:
            print(f"✗ Custom data generator test failed: {e}")
            import traceback
            traceback.print_exc()
            return False


def test_custom_simulation_runner():
    """
    Test the custom simulation runner independently.
    """
    print("Testing custom simulation runner...")
    
    try:
        # Create temporary directory
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            output_dir = temp_path / "sim_output"
            
            # Create a simple input template
            input_template = temp_path / "input.txt"
            input_template.write_text("Test input template")
            
            # Create runner
            runner = CustomSimulationRunner({"working_dir": str(temp_path)})
            
            # Test simulation run
            parameters = {
                "amplitude": 1.0,
                "frequency": 1.0,
                "phase": 0.0,
                "noise_level": 0.1,
                "data_size": 50
            }
            
            result = runner.run_simulation(str(input_template), str(output_dir), parameters)
            
            # Verify result
            assert result["status"] == "success", "Simulation should succeed"
            assert os.path.exists(result["output_file"]), "Output file should exist"
            assert result["parameters"] == parameters, "Parameters should match"
            
            # Load and verify data
            data = np.load(result["output_file"])
            assert data.shape == (50, 2), f"Data shape should be (50, 2), got {data.shape}"
            
        print("✓ Custom simulation runner test passed")
        return True
        
    except Exception as e:
        print(f"✗ Custom simulation runner test failed: {e}")
        import traceback
        traceback.print_exc()
        return False


def test_custom_data_extractor():
    """
    Test the custom data extractor independently.
    """
    print("Testing custom data extractor...")
    
    try:
        # Create temporary directory
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)
            
            # Create test data
            x = np.linspace(0, 2*np.pi, 100)
            y = np.sin(x) + np.random.normal(0, 0.1, 100)
            test_data = np.column_stack([x, y])
            
            # Save test data
            test_file = temp_path / "test_data.npy"
            np.save(test_file, test_data)
            
            # Create extractor
            extractor = CustomDataExtractor()
            
            # Extract data
            extracted = extractor.extract_data(str(test_file))
            
            # Verify extraction
            assert "features" in extracted, "Extracted data should contain features"
            assert "targets" in extracted, "Extracted data should contain targets"
            assert extracted["features"].shape == (100,), f"Features shape should be (100,), got {extracted['features'].shape}"
            assert extracted["targets"].shape == (100,), f"Targets shape should be (100,), got {extracted['targets'].shape}"
            
        print("✓ Custom data extractor test passed")
        return True
        
    except Exception as e:
        print(f"✗ Custom data extractor test failed: {e}")
        import traceback
        traceback.print_exc()
        return False


def main():
    """
    Main test function.
    """
    print("Running custom data generator tests")
    print("=" * 50)
    
    # Run individual component tests
    test1_passed = test_custom_simulation_runner()
    test2_passed = test_custom_data_extractor()
    
    # Run integrated test
    test3_passed = test_custom_data_generator()
    
    print("\n" + "=" * 50)
    if test1_passed and test2_passed and test3_passed:
        print("🎉 All custom data generator tests passed!")
        return True
    else:
        print("❌ Some tests failed!")
        return False


if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1)